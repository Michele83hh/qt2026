"""
CCNA Question Extraction using Google Gemini 2.0 Flash
Ultra-low cost: ~$0.50 for all 628 images

Setup:
1. pip install google-generativeai pillow
2. Get API key: https://aistudio.google.com/apikey
3. Set environment variable:
   Windows CMD: set GOOGLE_API_KEY=your-key-here
   Windows PowerShell: $env:GOOGLE_API_KEY="your-key-here"
   Linux/Mac: export GOOGLE_API_KEY="your-key-here"

Usage:
    # Test with first 10 images
    python extract_with_gemini.py --test

    # Extract all 628 images
    python extract_with_gemini.py --full

    # Extract specific range
    python extract_with_gemini.py --start 0 --end 50
"""

import os
import json
import sys
from pathlib import Path
from datetime import datetime
import base64
import argparse
import time

try:
    import google.generativeai as genai
    from PIL import Image
except ImportError:
    print("ERROR: Missing dependencies!")
    print("Please run: pip install google-generativeai pillow")
    sys.exit(1)

# Configuration
BASE_DIR = Path(__file__).parent
QUESTIONS_DIR = BASE_DIR / "Fragen"
OUTPUT_DIR = BASE_DIR / "data"
OUTPUT_DIR.mkdir(exist_ok=True)

# Check API key
API_KEY = os.getenv("GOOGLE_API_KEY")
if not API_KEY:
    print("ERROR: GOOGLE_API_KEY not set!")
    print("\nPlease set your API key:")
    print("  Windows CMD: set GOOGLE_API_KEY=your-key-here")
    print("  Windows PowerShell: $env:GOOGLE_API_KEY=\"your-key-here\"")
    print("  Linux/Mac: export GOOGLE_API_KEY=\"your-key-here\"")
    print("\nGet your key here: https://aistudio.google.com/apikey")
    sys.exit(1)

# Configure Gemini
genai.configure(api_key=API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash-exp')

# Topic mapping from topic reference to category
def categorize_from_topic(topic_ref: str, question_text: str) -> str:
    """Map topic reference to CCNA category"""
    if not topic_ref:
        # Content-based fallback
        text_lower = question_text.lower()
        if any(word in text_lower for word in ["vlan", "switch", "trunk", "stp", "wireless", "etherchannel"]):
            return "Network Access"
        elif any(word in text_lower for word in ["routing", "ospf", "eigrp", "rip", "hsrp", "vrrp"]):
            return "IP Connectivity"
        elif any(word in text_lower for word in ["dhcp", "nat", "pat", "ntp", "snmp", "syslog"]):
            return "IP Services"
        elif any(word in text_lower for word in ["security", "acl", "firewall", "aaa", "password", "encryption"]):
            return "Security Fundamentals"
        elif any(word in text_lower for word in ["api", "json", "python", "automation", "rest", "sdn"]):
            return "Automation and Programmability"
        return "Network Fundamentals"

    # Extract topic number (e.g., "Topic 1.8.0" -> "1")
    try:
        parts = topic_ref.split()
        if len(parts) >= 2:
            topic_num = parts[1].split('.')[0]
            topic_map = {
                "1": "Network Fundamentals",
                "2": "Network Access",
                "3": "IP Connectivity",
                "4": "IP Services",
                "5": "Security Fundamentals",
                "6": "Automation and Programmability"
            }
            return topic_map.get(topic_num, "Network Fundamentals")
    except:
        pass

    return "Network Fundamentals"

# Extraction prompt
EXTRACTION_PROMPT = """You are extracting CCNA exam questions from a screenshot. The screenshot shows:
1. A question number at the top
2. The question text
3. Multiple choice options (usually 4)
4. The correct answer(s) marked with a BLUE background and white checkmark
5. Wrong answers have a GRAY background
6. An explanation section at the bottom starting with "Correct" or "Topic X.Y.Z"

**CRITICAL: Identifying Correct Answers**
- Look for options with BLUE background + white checkmark icon = CORRECT
- Gray background = WRONG
- Count how many blue options there are

**Your task:**
Extract ALL information and return ONLY valid JSON (no markdown, no code blocks) in this exact format:

{
  "questionText": "exact question text here...",
  "options": ["option 1", "option 2", "option 3", "option 4"],
  "correctAnswerIndexes": [2],
  "multipleAnswers": false,
  "explanation": "full explanation text...",
  "topicReference": "Topic 1.8.0",
  "difficulty": "medium",
  "extractionConfidence": "high"
}

**Field Requirements:**
- questionText: Exact text, preserve all words
- options: Array of all answer options (min 3)
- correctAnswerIndexes: 0-based indexes of BLUE options with checkmarks [0,1] or [2]
- multipleAnswers: true if 2+ correct answers, false if only 1
- explanation: Complete explanation text from bottom of screenshot
- topicReference: "Topic X.Y.Z" format from explanation, or "" if not found
- difficulty: "easy" / "medium" / "hard" based on complexity
- extractionConfidence: "high" if all clear, "medium" if some uncertainty, "low" if significant issues

**Important:**
- Return ONLY the JSON object, nothing else
- No markdown code blocks (```json)
- No explanatory text before or after
- Ensure valid JSON syntax"""

def extract_question_from_image(image_path: Path, question_number: int) -> dict:
    """Extract a single question using Gemini Vision"""
    try:
        print(f"  Processing: {image_path.name}...", end=" ", flush=True)

        # Load image
        img = Image.open(image_path)

        # Call Gemini API
        response = model.generate_content([EXTRACTION_PROMPT, img])

        # Parse response
        response_text = response.text.strip()

        # Remove markdown code blocks if present
        if response_text.startswith("```"):
            lines = response_text.split("\n")
            response_text = "\n".join(lines[1:-1]) if len(lines) > 2 else response_text
            response_text = response_text.replace("```json", "").replace("```", "").strip()

        data = json.loads(response_text)

        # Validate required fields
        required = ["questionText", "options", "correctAnswerIndexes", "multipleAnswers", "explanation"]
        for field in required:
            if field not in data:
                raise ValueError(f"Missing required field: {field}")

        # Categorize
        topic = categorize_from_topic(
            data.get("topicReference", ""),
            data["questionText"]
        )

        # Clean explanation text
        explanation = data["explanation"]
        # Remove "Correct\n" prefix if present
        if explanation.startswith("Correct\n"):
            explanation = explanation[8:]  # Remove "Correct\n"
        elif explanation.startswith("Correct "):
            explanation = explanation[8:]  # Remove "Correct "
        # Replace mid-text line breaks with spaces
        explanation = explanation.replace("\n", " ").strip()

        # Build question object
        question = {
            "id": f"ext-{str(question_number).zfill(3)}",
            "source": "manual",
            "topic": topic,
            "subtopic": data.get("topicReference", ""),
            "difficulty": data.get("difficulty", "medium"),
            "type": "multiple-choice-multiple" if data["multipleAnswers"] else "multiple-choice-single",
            "question": data["questionText"],
            "options": data["options"],
            "correctAnswer": data["correctAnswerIndexes"],
            "explanation": explanation,
            "references": [data["topicReference"]] if data.get("topicReference") else [],
            "tags": [],
            "_extractionConfidence": data.get("extractionConfidence", "medium"),
            "_needsReview": data.get("extractionConfidence", "medium") != "high"
        }

        print(f"✓ [{data.get('extractionConfidence', '?')}]")
        return question

    except json.JSONDecodeError as e:
        print(f"✗ JSON Error: {e}")
        print(f"Response was: {response_text[:200]}...")
        return None
    except Exception as e:
        print(f"✗ Error: {e}")
        return None

def extract_questions(start_idx: int = 0, end_idx: int = None, output_file: str = "extracted_questions.json"):
    """Extract questions from PNG screenshots"""

    # Get all PNG files
    png_files = sorted(QUESTIONS_DIR.glob("*.png"))

    if not png_files:
        print(f"ERROR: No PNG files found in {QUESTIONS_DIR}")
        return

    total_files = len(png_files)
    print(f"Found {total_files} PNG files in {QUESTIONS_DIR}")

    # Determine range
    if end_idx is None:
        end_idx = total_files

    end_idx = min(end_idx, total_files)
    files_to_process = png_files[start_idx:end_idx]

    print(f"Processing files {start_idx+1} to {end_idx} ({len(files_to_process)} files)")
    print(f"Output: {OUTPUT_DIR / output_file}")
    print("-" * 60)

    # Extract questions
    questions = []
    failed = []

    for idx, png_file in enumerate(files_to_process):
        question_num = start_idx + idx + 1
        print(f"[{question_num}/{end_idx}]", end=" ")

        question = extract_question_from_image(png_file, question_num)

        if question:
            questions.append(question)
        else:
            failed.append((question_num, png_file.name))

        # Rate limiting (Gemini allows 15 RPM free tier)
        if (idx + 1) % 10 == 0:
            print("  Rate limit pause (5s)...")
            time.sleep(5)
        else:
            time.sleep(0.5)

    print("-" * 60)
    print(f"Extraction complete!")
    print(f"  ✓ Successful: {len(questions)}")
    print(f"  ✗ Failed: {len(failed)}")

    if failed:
        print("\nFailed extractions:")
        for num, name in failed:
            print(f"  - Question {num}: {name}")

    # Calculate confidence stats
    if questions:
        high_conf = sum(1 for q in questions if q.get("_extractionConfidence") == "high")
        med_conf = sum(1 for q in questions if q.get("_extractionConfidence") == "medium")
        low_conf = sum(1 for q in questions if q.get("_extractionConfidence") == "low")

        print(f"\nConfidence levels:")
        print(f"  High: {high_conf} ({high_conf/len(questions)*100:.1f}%)")
        print(f"  Medium: {med_conf} ({med_conf/len(questions)*100:.1f}%)")
        print(f"  Low: {low_conf} ({low_conf/len(questions)*100:.1f}%)")
    else:
        print(f"\n⚠️  No successful extractions - all {len(failed)} failed!")
        print("\nPossible causes:")
        print("  1. API key incorrect or expired")
        print("  2. Rate limit exceeded")
        print("  3. Gemini returned invalid JSON")
        print("  4. Network connectivity issues")
        print("\nCheck the error messages above for details.")

    # Save to JSON
    output_path = OUTPUT_DIR / output_file
    output_data = {
        "version": "1.0",
        "extractionDate": datetime.now().isoformat(),
        "extractionMethod": "google-gemini-2.0-flash-exp",
        "totalQuestions": len(questions),
        "successRate": f"{len(questions)/len(files_to_process)*100:.1f}%",
        "questions": questions
    }

    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(output_data, f, indent=2, ensure_ascii=False)

    print(f"\n✓ Saved to: {output_path}")
    print(f"\nEstimated cost: ~${len(files_to_process) * 0.0008:.2f}")

    return questions

def main():
    parser = argparse.ArgumentParser(description="Extract CCNA questions using Google Gemini")
    parser.add_argument("--test", action="store_true", help="Test with first 10 images")
    parser.add_argument("--full", action="store_true", help="Extract all 628 images")
    parser.add_argument("--start", type=int, default=0, help="Start index")
    parser.add_argument("--end", type=int, help="End index")
    parser.add_argument("--output", type=str, default="extracted_questions.json", help="Output filename")

    args = parser.parse_args()

    print("=" * 60)
    print("CCNA Question Extraction with Google Gemini 2.0 Flash")
    print("=" * 60)

    if args.test:
        print("MODE: Test (first 10 images)")
        extract_questions(0, 10, "test_extraction.json")
    elif args.full:
        print("MODE: Full extraction (all images)")
        extract_questions(0, None, "full_extraction.json")
    elif args.end:
        print(f"MODE: Custom range ({args.start} to {args.end})")
        extract_questions(args.start, args.end, args.output)
    else:
        print("ERROR: Please specify --test, --full, or --start/--end")
        print("\nExamples:")
        print("  python extract_with_gemini.py --test")
        print("  python extract_with_gemini.py --full")
        print("  python extract_with_gemini.py --start 0 --end 50")
        sys.exit(1)

if __name__ == "__main__":
    main()
